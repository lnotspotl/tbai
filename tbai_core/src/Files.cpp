#include <fcntl.h>
#include <unistd.h>

#include <filesystem>

#include <tbai_core/Files.hpp>
#include <tbai_core/Throws.hpp>

namespace tbai {

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
FSLock::FSLock(const std::string &fname) : filename_(fname), isLocked_(false), threadLock_(getThreadLock(fname)) {}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
FSLock::~FSLock() {
    if (holding()) unlock();
    if (fd_ != -1) close(fd_);
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
void FSLock::lock() {
    threadLock_.lock();

    lockPath_ = getLockPath(filename_);

    fd_ = open(lockPath_.c_str(), O_RDWR | O_CREAT, 0666);
    if (fd_ == -1) {
        threadLock_.unlock();  // Release thread lock if file lock fails
        TBAI_THROW("Failed to open file: " + lockPath_);
    }

    struct flock fl {};
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = 0;
    if (fcntl(fd_, F_SETLKW, &fl) == -1) {
        threadLock_.unlock();  // Release thread lock if file lock fails
        TBAI_THROW("Failed to acquire lock on file: " + lockPath_);
    }

    isLocked_ = true;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
void FSLock::unlock() {
    struct flock fl {};
    fl.l_type = F_UNLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = 0;
    TBAI_THROW_UNLESS(fcntl(fd_, F_SETLK, &fl) == 0, "Failed to release lock on file: " + lockPath_);

    isLocked_ = false;
    threadLock_.unlock();  // Release the thread lock after file lock is released
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
bool FSLock::holding() const {
    return isLocked_;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
FileLock::FileLock(const std::string &path, bool createIfNotExists) : FSLock(path) {
    TBAI_THROW_UNLESS(createIfNotExists || std::filesystem::exists(path), "File does not exist: " + path);
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
std::string FileLock::getLockPath(const std::string &path) {
    return path;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
FolderLock::FolderLock(const std::string &path) : FSLock(path) {
    TBAI_THROW_UNLESS(std::filesystem::exists(path), "Folder does not exist: " + path);
    TBAI_THROW_UNLESS(std::filesystem::is_directory(path), "Path is not a folder: " + path);
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
std::string FolderLock::getLockPath(const std::string &path) {
    return path + "/.folder_lock";
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
std::unique_ptr<FileLock> FileLock::lock(const std::string &path, bool createIfNotExists) {
    auto fileLock = std::make_unique<FileLock>(path, createIfNotExists);
    fileLock->lock();
    return fileLock;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
std::unique_ptr<FolderLock> FolderLock::lock(const std::string &path) {
    auto folderLock = std::make_unique<FolderLock>(path);
    folderLock->lock();
    return folderLock;
}

}  // namespace tbai